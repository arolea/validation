import com.rolea.learning.validation.domain.Product;
import com.rolea.learning.validation.domain.Category;
import com.rolea.learning.validation.service.ValidationWarning;
import com.rolea.learning.validation.service.ValidationResultContainer;
import com.rolea.learning.validation.service.ProductAdditionalData;

global ValidationResultContainer resultContainer;
global ProductAdditionalData additionalData;

function boolean validateClashingCategories(Product product) {
    String firstCategoryName = "Category 1";
    String secondCategoryName = "Category 2";

    if(product.getCategories() == null || product.getCategories().size() == 0){
        return false;
    }

    boolean containsFirstCategory = product.getCategories().stream()
        .anyMatch(category -> firstCategoryName.equals(category.getName()));
    boolean containsSecondCategory = product.getCategories().stream()
            .anyMatch(category -> secondCategoryName.equals(category.getName()));

    return containsFirstCategory && containsSecondCategory;
}

rule "Product has no clashing categories (a product can't be part of both 'Category 1' and 'Category 2')"
    salience 10
    when
        productInstance:Product()
        eval(validateClashingCategories(productInstance))
    then
        String message = String.format("Product with id %d has clashing categories", productInstance.getId());
        resultContainer.addValidationWarning(productInstance, message);
end

rule "Product has no clashing categories (a product can't be part of both 'Category 1' and 'Category 2') - no function"
    salience 10
    when
        productInstance : Product()
        Category(name == "Category 1") from productInstance.categories
        Category(name == "Category 2") from productInstance.categories
    then
        String message = String.format("Product with id %d has clashing categories", productInstance.getId());
        resultContainer.addValidationWarning(productInstance, message);
end